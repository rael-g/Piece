# Logging Strategy

This document outlines the comprehensive logging strategy for the project, covering both C++ and C# components, cross-language interoperability, and performance considerations critical for a graphics engine.

## 1. Core Principles

*   **Consistency:** Maintain consistent log levels and formatting across both C++ and C# components.
*   **Performance:** Minimize logging overhead, especially in performance-critical C++ engine code.
*   **Observability:** Provide sufficient detail for debugging, monitoring, and understanding application behavior.
*   **Flexibility:** Allow dynamic configuration of log levels and output destinations.
*   **Interop:** Seamlessly integrate C++ logs into the C# editor environment.

## 2. Chosen Logging Libraries

*   **C++: `spdlog`**
    *   **Reasoning:** Selected for its exceptional performance, low-latency asynchronous logging capabilities, low memory allocation overhead, rapid formatting, and highly optimized sinks. It is ideal for the demanding requirements of a graphics engine.
*   **C#: `Serilog`**
    *   **Reasoning:** Chosen for its robust structured logging capabilities, extensive configurability, and wide array of available sinks. `Serilog` is well-suited for the C# editor environment, where rich, searchable logs are valuable, and the performance demands are less stringent than the C++ engine core.

## 3. Log Levels

To maintain consistency and provide granular control over log verbosity, the following log levels will be used across both C++ and C# components:

*   **`Trace`**: Highly detailed events, typically used for debugging purposes only during development.
*   **`Debug`**: Debugging information, useful for developers to diagnose issues.
*   **`Info`**: General application flow and significant events (e.g., initialization, module loading).
*   **`Warning`**: Potentially harmful situations or unusual occurrences that might indicate a problem (e.g., deprecated API usage, recoverable errors).
*   **`Error`**: Error events that prevent specific operations from completing but might still allow the application to continue running (e.g., failed resource loading).
*   **`Fatal`**: Critical errors that cause the application to crash, become unusable, or enter an unrecoverable state.

## 4. Output Destinations (Sinks)

Logging output will be directed to various destinations depending on the environment and build configuration:

*   **Development Builds:**
    *   **Console:** Colored output to the console for immediate feedback.
    *   **Debug Output:** Output to the IDE's debug output window (e.g., Visual Studio Output window).
    *   **File:** Rolling file logs for persistent history and easier sharing.
*   **Production/Release Builds:**
    *   **File:** Rolling file logs (with configurable size and count limits) for post-mortem analysis.
    *   **Crash Reporting (Future):** Potentially integrate with a crash reporting service for `Error` and `Fatal` logs.
*   **Editor Environment:**
    *   Logs from both C++ and C# will be consolidated and displayed within a dedicated log window or console panel within the C# editor UI.

## 5. Cross-Language Logging (C++ to C# Interoperability)

A key aspect of this strategy is the seamless integration of C++ engine logs into the C# editor environment. This will be achieved via a P/Invoke callback mechanism:

1.  **C++ Export Function (`PieceIntermediate_Log`):**
    *   A C-style function, `PieceIntermediate_Log(int level, const char* message)`, will be exposed from the C++ `PieceIntermediate.dll` using `__declspec(dllexport)`. This function will be the entry point for C++ log messages intended for the C# side.
    *   A `LogCallback` delegate type and a registration function `PieceIntermediate_RegisterLogCallback(LogCallback callback)` will also be exported to allow C# to provide a callback.
2.  **`spdlog` Custom Sink:**
    *   In the C++ codebase, `spdlog` will be configured with a custom sink. This sink will capture log messages generated by `spdlog` within the C++ engine.
    *   Upon receiving a log message, this custom sink will format the message and then invoke the C# callback (if registered) via the `PieceIntermediate_Log` export function, passing the log level and message content. This ensures `spdlog`'s efficient formatting is utilized.
3.  **C# `DllImport` and Callback:**
    *   In the `Piece.Core.Interop` C# project, `DllImport` attributes will be used to declare the C++ `PieceIntermediate_Log` and `PieceIntermediate_RegisterLogCallback` functions.
    *   A C# delegate matching the `LogCallback` signature will be defined.
    *   During the C# editor's initialization, an instance of this delegate (pointing to a C# method that processes the log) will be created and passed to the C++ side using `PieceIntermediate_RegisterLogCallback`.
    *   The C# callback method will receive the C++ log messages and forward them to the `Serilog` instance, allowing them to be processed and displayed alongside native C# logs.

## 6. Thread Safety

Both `spdlog` and `Serilog` are designed with thread safety in mind. Proper configuration of their respective sinks and asynchronous modes will ensure that logging operations do not introduce race conditions or deadlocks in the multi-threaded engine and editor environment.

## 7. Configuration Management

*   **C++:** Log levels and sink configurations for `spdlog` will initially be set programmatically during the engine's initialization. For more advanced scenarios, a lightweight configuration file (e.g., INI, simple JSON) could be parsed at startup.
*   **C#:** `Serilog` will be configured primarily through `appsettings.json`, offering easy modification without recompilation. Programmatic overrides will be available for dynamic adjustments (e.g., changing log levels during a debugging session in the editor).

## 8. Implementation Steps Overview

1.  **C++ (`spdlog`):**
    *   Integrate `spdlog` into the CMake build system.
    *   Define C++ `LogLevel` enum.
    *   Initialize global `spdlog` logger with console and file sinks.
    *   Replace existing `std::cerr` with `spdlog`.
    *   Implement C++ export functions for C# interop and a custom `spdlog` sink to utilize them.
    *   Add logging calls at key engine points.
2.  **C# (`Serilog`):**
    *   Add `Serilog` NuGet packages to relevant projects.
    *   Define C# `LogLevel` enum.
    *   Initialize `Serilog` with console, debug, and file sinks, configured via `appsettings.json`.
    *   Implement `DllImport` declarations and the C# callback method for C++ logs in `Piece.Core.Interop`.
    *   Register the C# log callback with the C++ side during C# application startup.
    *   Add logging calls at key C# application points.
3.  **Centralized Access:** Create simple logger wrappers in both languages for consistent access.